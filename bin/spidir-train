#!/usr/bin/env python
# train the SPIDIR model
# Sun Apr  5 17:47:47 EDT 2009

import os, sys, optparse

from rasmus import treelib, util, stats

import spidir


o = optparse.OptionParser()
o.set_defaults()

o.add_option("-s", "--stree", dest="stree",
             metavar="<species tree newick file>")
o.add_option("-l", "--lenmatrix", dest="lenmatrix",
             metavar="<branch length matrix output file>")
o.add_option("-n", "--niter", dest="niter",
             metavar="<number of iterations>",
             type="int")
o.add_option("-r", "--nrates", dest="nrates",             
             metavar="<number of rate categories>",
             type="int",
             default=20)
o.add_option("-p", "--params", dest="params",
             metavar="<output parameters file>")



def read_length_matrix(filename, minlen=.0001, maxlen=1.0):
    dat = util.read_delim(filename)
    species = dat[0]
    lens = util.map2(float, dat[1:])

    for row in lens:
        for i in xrange(len(row)):
            if row[i] <= 0.0:
                row[i] = minlen

    # remove high lengths
    cols = zip(* lens)
    means = map(stats.mean, cols)

    for row in lens:
        for i in xrange(len(row)):
            if row[i] > maxlen:
                row[i] = means[i]
    
    return species, lens

    
def write_params_list(filename, species, params, logls):
    
    out = open(filename, "w")

    headers = ["iter", "logl"] + [str(sp)+p for sp in species
                                  for p in ("_a", "_b")]
    out.write("\t".join(headers) + "\n")

    for i, (p, l) in enumerate(zip(params, logls)):

        vals = [p[sp][i] for sp in species for i in (0, 1)]
        out.write("%d\t%f\t" % (i, l) + "\t".join(map(str, vals)) + "\n")

    out.close()

    
def main(conf, args):

    term_iters = 10
    term_step = 1.0

    if conf.stree is None or \
       conf.lenmatrix is None:
        print >>sys.stderr, "missing required arguments"
        return 1
    
    # read data
    stree = treelib.readTree(conf.stree)
    times = [node.dist for node in stree.postorder() if node.parent]

    species, lens = read_length_matrix(conf.lenmatrix)
    for i, sp in enumerate(species):
        if isinstance(sp, basestring) and sp.isdigit():
            species[i] = int(sp)

    logls = []
        
    em = spidir.alloc_rates_em(lens, times, species, conf.nrates)

    spidir.RatesEM_Init(em)

    params_list = [spidir.rates_em_get_params(em, species)]

    util.tic("EM")
    while True:

        # test termination
        if conf.niter is not None:
            if len(logls) > conf.niter:
                break
        else:
            if len(logls) > term_iters and \
               logls[-term_iters] + term_step > logls[-1]:
                break
        
        util.tic("iter %d" % len(logls))
        util.tic("E step")
        spidir.RatesEM_EStep(em)
        util.toc()

        lk = spidir.RatesEM_likelihood(em)
        util.logger("logl:", lk)
        logls.append(lk)

        util.tic("M step")
        spidir.RatesEM_MStep(em)
        util.toc()
        util.toc()

        params_list.append(spidir.rates_em_get_params(em, species))
        
    runtime = util.toc()

    # print final likelihood
    spidir.RatesEM_EStep(em)
    lk = spidir.RatesEM_likelihood(em)
    util.logger("logl:", lk)
    logls.append(lk)

    print "\t".join(map(str, logls))
    print runtime

    params = spidir.rates_em_get_params(em, species)
    params[1] = params["baserate"]
    params_list.append(params)
    
    if conf.params is not None:
        spidir.write_params(conf.params, params)
        write_params_list(conf.params + ".fitting", species,
                          params_list, logls)
        
    else:
        util.print_dict(params)
    
    spidir.free_rates_em(em)

    return 0


conf, args = o.parse_args()
sys.exit(main(conf, args))
